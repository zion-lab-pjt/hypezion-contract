// SPDX-License-Identifier: MIT
pragma solidity ^0.8.22;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * @title IMetaAggregationRouterV2
 * @notice Interface for KyberSwap MetaAggregationRouterV2
 * @dev Extracted from MetaAggregationRouterV2.sol deployed on HyperEVM
 *
 * IMPORTANT USAGE GUIDELINES:
 * ==========================
 *
 * 1. DO NOT construct SwapExecutionParams manually
 *    - The `targetData` field is extremely complex and routing-dependent
 *    - Must be obtained from KyberSwap API
 *
 * 2. ALWAYS use KyberSwap API to get swap data:
 *    Step 1: GET https://aggregator-api.kyberswap.com/hyperevm/api/v1/routes
 *            Parameters: tokenIn, tokenOut, amountIn
 *            Returns: routeSummary with optimal route
 *
 *    Step 2: POST https://aggregator-api.kyberswap.com/hyperevm/api/v1/route/build
 *            Body: { routeSummary, sender, recipient, slippageTolerance }
 *            Returns: { data: encodedSwapData, routerAddress, amountOut, ... }
 *
 * 3. RECOMMENDED: Use low-level call instead of type-safe call
 *    Example:
 *    ```solidity
 *    (bool success, bytes memory result) = router.call(encodedSwapData);
 *    require(success, "Swap failed");
 *    (uint256 returnAmount, uint256 gasUsed) = abi.decode(result, (uint256, uint256));
 *    ```
 *
 * 4. Router Address (HyperEVM):
 *    Mainnet/Testnet: 0x6131B5fae19EA4f9D964eAc0408E4408b66337b5
 *
 * 5. Token Approval:
 *    - Approve router to spend input tokens BEFORE calling swap
 *    - Clear approval AFTER swap for security
 *
 * 6. Slippage Protection:
 *    - Set desc.minReturnAmount appropriately
 *    - Typically: expectedOutput * (1 - slippageTolerance)
 *    - Example: 0.5% slippage = expectedOutput * 0.995
 *
 * REFERENCE:
 * - API Docs: https://docs.kyberswap.com/kyberswap-solutions/kyberswap-aggregator
 * - Example: CA/scripts/test-kyberswap-integration.js
 * - Research: thoughts/shared/research/2025-10-24-kyberswap-api-integration-analysis.md
 */
interface IMetaAggregationRouterV2 {
    // ==================== Structs ====================

    /**
     * @notice Swap description containing all swap parameters
     * @dev DO NOT construct manually - obtained from KyberSwap API
     *
     * FIELD EXPLANATIONS:
     *
     * @param srcToken Source token to swap from (e.g., kHYPE)
     * @param dstToken Destination token to swap to (e.g., WHYPE)
     * @param srcReceivers Addresses to receive source tokens (usually empty for simple swaps)
     *                     Used for complex multi-hop swaps with split routing
     * @param srcAmounts Amounts to send to each srcReceiver (usually empty)
     * @param feeReceivers Addresses to receive protocol fees (set by KyberSwap)
     * @param feeAmounts Fee amounts for each receiver (set by KyberSwap)
     * @param dstReceiver Address to receive destination tokens (your contract or user)
     * @param amount Total amount of source tokens to swap
     * @param minReturnAmount Minimum acceptable amount of destination tokens
     *                        CRITICAL: Set this for slippage protection!
     *                        Formula: expectedOutput * (1 - slippageTolerance)
     * @param flags Bit flags for swap options (set by KyberSwap API)
     *              Flags control routing behavior and optimizations
     * @param permit Permit signature for gasless approval (usually empty)
     *               Used for EIP-2612 permit functionality
     */
    struct SwapDescriptionV2 {
        IERC20 srcToken;
        IERC20 dstToken;
        address[] srcReceivers;
        uint256[] srcAmounts;
        address[] feeReceivers;
        uint256[] feeAmounts;
        address dstReceiver;
        uint256 amount;
        uint256 minReturnAmount;
        uint256 flags;
        bytes permit;
    }

    /**
     * @notice Parameters for swap execution
     * @dev This struct is populated by KyberSwap API - DO NOT construct manually
     *
     * CRITICAL FIELD: targetData
     * ============================
     * The `targetData` field contains the complete routing logic for the swap.
     * This is a highly complex, ABI-encoded payload that:
     * - Specifies which DEX pools to use
     * - Defines the exact execution path
     * - Contains optimized routing parameters
     * - Is generated by KyberSwap's off-chain routing engine
     *
     * IMPORTANT: This entire struct comes from API response.data.data
     *
     * FIELD EXPLANATIONS:
     *
     * @param callTarget Address to call for swap execution
     *                   The executor contract that performs the actual swap
     * @param approveTarget Address to approve for token spending
     *                      Router will approve this address to spend tokens
     * @param targetData Encoded routing and execution data (MOST COMPLEX FIELD)
     *                   Contains the complete swap execution logic
     *                   Generated by KyberSwap routing engine
     * @param desc Swap description with all parameters (see SwapDescriptionV2)
     * @param clientData Additional client-specific data (usually empty)
     *                   Can be used for tracking or custom logic
     *
     * EXAMPLE USAGE:
     * ```
     * // Frontend gets this entire struct from API:
     * const apiResponse = await axios.post('.../route/build', { ... });
     * const encodedSwapData = apiResponse.data.data.data; // Complete ABI-encoded call
     *
     * // Smart contract uses low-level call:
     * (bool success, bytes memory result) = router.call(encodedSwapData);
     * ```
     */
    struct SwapExecutionParams {
        address callTarget;
        address approveTarget;
        bytes targetData;
        SwapDescriptionV2 desc;
        bytes clientData;
    }

    /**
     * @notice Simple swap data structure (for simple mode swaps)
     * @param firstPools Initial pool addresses
     * @param firstSwapAmounts Amounts for first swap
     * @param swapDatas Encoded swap data for each hop
     * @param deadline Swap deadline timestamp
     * @param positiveSlippageData Data for positive slippage handling
     */
    struct SimpleSwapData {
        address[] firstPools;
        uint256[] firstSwapAmounts;
        bytes[] swapDatas;
        uint256 deadline;
        bytes positiveSlippageData;
    }

    // ==================== Events ====================

    /**
     * @notice Emitted when a swap is executed
     * @param sender Address that initiated the swap
     * @param srcToken Source token address
     * @param dstToken Destination token address
     * @param dstReceiver Address that received destination tokens
     * @param spentAmount Amount of source tokens spent
     * @param returnAmount Amount of destination tokens received
     */
    event Swapped(
        address sender,
        IERC20 srcToken,
        IERC20 dstToken,
        address dstReceiver,
        uint256 spentAmount,
        uint256 returnAmount
    );

    event ClientData(bytes clientData);
    event Exchange(address pair, uint256 amountOut, address output);

    /**
     * @notice Emitted when fees are collected
     * @param token Token address for fees
     * @param totalAmount Total amount before fees
     * @param totalFee Total fee amount
     * @param recipients Fee recipient addresses
     * @param amounts Fee amounts for each recipient
     * @param isBps Whether amounts are in basis points
     */
    event Fee(
        address token,
        uint256 totalAmount,
        uint256 totalFee,
        address[] recipients,
        uint256[] amounts,
        bool isBps
    );

    // ==================== Functions ====================

    /**
     * @notice Execute a token swap using KyberSwap aggregator
     * @dev This is the main function called by our DEX integration
     *
     * BEFORE CALLING THIS FUNCTION:
     * ==============================
     * 1. ✅ Get swap data from KyberSwap API (POST /route/build)
     * 2. ✅ Approve router to spend input tokens
     * 3. ✅ Validate minReturnAmount is set correctly
     * 4. ✅ Check you have enough input tokens
     *
     * SECURITY CHECKLIST:
     * ===================
     * - [ ] Input tokens approved to router
     * - [ ] minReturnAmount protects against slippage
     * - [ ] Deadline set (if supported by API)
     * - [ ] Recipient address is correct
     * - [ ] Using ReentrancyGuard on your contract
     * - [ ] Verify balance before and after swap
     *
     * COMMON ERRORS:
     * ==============
     * - "Min return should not be 0" → Set desc.minReturnAmount > 0
     * - "executorData should be not zero" → targetData must not be empty
     * - "ERC20: insufficient allowance" → Approve router first
     * - "ERC20: transfer amount exceeds balance" → Insufficient input tokens
     *
     * RECOMMENDED USAGE (Low-Level Call):
     * ====================================
     * Instead of calling this function directly, use low-level call for flexibility:
     *
     * ```solidity
     * // Get encoded data from API
     * bytes memory encodedSwapData = ... // from KyberSwap API
     *
     * // Approve tokens
     * IERC20(tokenIn).approve(router, amountIn);
     *
     * // Execute with low-level call
     * (bool success, bytes memory result) = router.call(encodedSwapData);
     * require(success, "Swap failed");
     *
     * // Decode return values
     * (uint256 returnAmount, uint256 gasUsed) = abi.decode(result, (uint256, uint256));
     *
     * // Clear approval
     * IERC20(tokenIn).approve(router, 0);
     * ```
     *
     * ALTERNATIVE (Type-Safe Call):
     * ==============================
     * ```solidity
     * IMetaAggregationRouterV2 router = IMetaAggregationRouterV2(routerAddress);
     * (uint256 returnAmount, uint256 gasUsed) = router.swap(executionParams);
     * ```
     *
     * @param execution Swap execution parameters (from KyberSwap API)
     *                  All fields must be populated by API response
     * @return returnAmount Actual amount of destination tokens received
     *                      Verify this meets your minimum requirements!
     * @return gasUsed Gas consumed by the swap execution
     *                 Useful for tracking and optimization
     */
    function swap(SwapExecutionParams calldata execution)
        external
        payable
        returns (uint256 returnAmount, uint256 gasUsed);
}
